    

    // Also, fill the dp array with -1, because this answer is never possible.
    // dp[i][j] = max value that can be generated by using the items from the ith index and a bag of jth capacity.
    
    private static int maxValueTopDown(int[] vls,int[] wt,int cap, int idx,int[][] dp)
    {
        if(cap == 0)
            return 0;

        if(idx == vls.length-1)
        {
            if(cap < wt[idx])
                return 0;
            return vls[idx];
        }

        if(dp[idx][cap] != -1)
            return dp[idx][cap];

        int rres = maxValueTopDown(vls,wt,cap,idx+1,dp); // if we exclude the current item

        if(cap - wt[idx] >= 0)
        {
            int rresTwo = maxValueTopDown(vls,wt,cap-wt[idx],idx+1,dp); // if we include the current item

            // If after including the current item we get more value than excluding it, then return this as it is more profitable

            if(rresTwo+vls[idx] > rres)
                return dp[idx][cap] = rresTwo+vls[idx];
        }    

        return dp[idx][cap] = rres;
    }
